{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-0162e121108a74c9643b1799fc6c70da61c3818c",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/JobFactory.sol": "project/contracts/JobFactory.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/JobEscrow.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\ncontract JobEscrow {\r\n    enum JobStatus { CREATED, FUNDED, IN_PROGRESS, SUBMITTED, COMPLETED, DISPUTED, REFUNDED }\r\n    \r\n    address public client;\r\n    address public freelancer;\r\n    address public platform;\r\n    uint256 public amount;\r\n    uint256 public platformFee;\r\n    uint256 public freelancerAmount;\r\n    JobStatus public status;\r\n    uint256 public workSubmittedAt;\r\n    uint256 public disputeTimeout = 7 days;\r\n    uint256 public approvalTimeout = 1 minutes; // Thời gian chờ phê duyệt công việc, điều chỉnh từ 3 ngày thành 1 phút để thuận tiện cho việc kiểm thử\r\n    address public arbitrator;\r\n    \r\n    string public jobId;\r\n    string public jobTitle;\r\n    \r\n    event JobFunded(address indexed client, uint256 amount);\r\n    event FreelancerAssigned(address indexed freelancer);\r\n    event WorkSubmitted(address indexed freelancer, uint256 timestamp);\r\n    event WorkApproved(address indexed client);\r\n    event PaymentReleased(address indexed freelancer, uint256 amount, address indexed platform, uint256 fee);\r\n    event DisputeInitiated(address indexed initiator, uint256 timestamp);\r\n    event DisputeResolved(address indexed resolver, bool favorFreelancer);\r\n    event Refunded(address indexed client, uint256 amount);\r\n    \r\n    modifier onlyClient() {\r\n        require(msg.sender == client, \"Only client can call this\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyFreelancer() {\r\n        require(msg.sender == freelancer, \"Only freelancer can call this\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyArbitrator() {\r\n        require(msg.sender == arbitrator, \"Only arbitrator can call this\");\r\n        _;\r\n    }\r\n    \r\n    modifier inStatus(JobStatus _status) {\r\n        require(status == _status, \"Invalid status for this operation\");\r\n        _;\r\n    }\r\n    \r\n    constructor(\r\n        address _client,\r\n        address _platform,\r\n        address _arbitrator,\r\n        uint256 _platformFeePercent,\r\n        string memory _jobId,\r\n        string memory _jobTitle\r\n    ) {\r\n        require(_client != address(0), \"Invalid client address\");\r\n        require(_platform != address(0), \"Invalid platform address\");\r\n        require(_arbitrator != address(0), \"Invalid arbitrator address\");\r\n        require(_platformFeePercent <= 100, \"Fee percent too high\");\r\n        \r\n        client = _client;\r\n        platform = _platform;\r\n        arbitrator = _arbitrator;\r\n        jobId = _jobId;\r\n        jobTitle = _jobTitle;\r\n        status = JobStatus.CREATED;\r\n    }\r\n    \r\n    // Step 1: Client funds the escrow\r\n    function fundEscrow(uint256 _platformFeePercent) external payable onlyClient inStatus(JobStatus.CREATED) {\r\n        require(msg.value > 0, \"Amount must be greater than 0\");\r\n        \r\n        amount = msg.value;\r\n        platformFee = (amount * _platformFeePercent) / 100;\r\n        freelancerAmount = amount - platformFee;\r\n        status = JobStatus.FUNDED;\r\n        \r\n        emit JobFunded(client, amount);\r\n    }\r\n    \r\n    // Step 2: Client assigns freelancer to the job\r\n    function assignFreelancer(address _freelancer) external onlyClient inStatus(JobStatus.FUNDED) {\r\n        require(_freelancer != address(0), \"Invalid freelancer address\");\r\n        require(_freelancer != client, \"Client cannot be freelancer\");\r\n        \r\n        freelancer = _freelancer;\r\n        status = JobStatus.IN_PROGRESS;\r\n        \r\n        emit FreelancerAssigned(freelancer);\r\n    }\r\n    \r\n    // Step 3: Freelancer submits work\r\n    function submitWork() external onlyFreelancer inStatus(JobStatus.IN_PROGRESS) {\r\n        workSubmittedAt = block.timestamp;\r\n        status = JobStatus.SUBMITTED;\r\n        \r\n        emit WorkSubmitted(freelancer, workSubmittedAt);\r\n    }\r\n    \r\n    // Step 4: Client approves work and automatic payout\r\n    function approveWork() external onlyClient inStatus(JobStatus.SUBMITTED) {\r\n        status = JobStatus.COMPLETED;\r\n        \r\n        emit WorkApproved(client);\r\n        \r\n        // Automatic payout\r\n        _releaseFunds();\r\n    }\r\n    \r\n    // Internal function to release funds\r\n    function _releaseFunds() private {\r\n        // Transfer to freelancer\r\n        (bool sentToFreelancer, ) = freelancer.call{value: freelancerAmount}(\"\");\r\n        require(sentToFreelancer, \"Failed to send to freelancer\");\r\n        \r\n        // Transfer platform fee\r\n        (bool sentToPlatform, ) = platform.call{value: platformFee}(\"\");\r\n        require(sentToPlatform, \"Failed to send to platform\");\r\n        \r\n        emit PaymentReleased(freelancer, freelancerAmount, platform, platformFee);\r\n    }\r\n    \r\n    // Dispute Resolution: Freelancer initiates dispute if client doesn't respond\r\n    function initiateDispute() external onlyFreelancer inStatus(JobStatus.SUBMITTED) {\r\n        require(block.timestamp >= workSubmittedAt + approvalTimeout, \"Approval timeout not reached\");\r\n        \r\n        status = JobStatus.DISPUTED;\r\n        \r\n        emit DisputeInitiated(freelancer, block.timestamp);\r\n    }\r\n    \r\n    // Arbitrator releases funds to freelancer\r\n    function releaseFundsToFreelancer() external onlyArbitrator inStatus(JobStatus.DISPUTED) {\r\n        status = JobStatus.COMPLETED;\r\n        \r\n        emit DisputeResolved(arbitrator, true);\r\n        \r\n        _releaseFunds();\r\n    }\r\n    \r\n    // Arbitrator refunds to client\r\n    function refundToClient() external onlyArbitrator inStatus(JobStatus.DISPUTED) {\r\n        status = JobStatus.REFUNDED;\r\n        \r\n        emit DisputeResolved(arbitrator, false);\r\n        \r\n        (bool sent, ) = client.call{value: amount}(\"\");\r\n        require(sent, \"Failed to refund to client\");\r\n        \r\n        emit Refunded(client, amount);\r\n    }\r\n    \r\n    // Client can cancel and get refund if freelancer not assigned yet\r\n    function cancelAndRefund() external onlyClient inStatus(JobStatus.FUNDED) {\r\n        status = JobStatus.REFUNDED;\r\n        \r\n        (bool sent, ) = client.call{value: amount}(\"\");\r\n        require(sent, \"Failed to refund to client\");\r\n        \r\n        emit Refunded(client, amount);\r\n    }\r\n    \r\n    // View functions\r\n    function getJobDetails() external view returns (\r\n        address _client,\r\n        address _freelancer,\r\n        uint256 _amount,\r\n        uint256 _platformFee,\r\n        uint256 _freelancerAmount,\r\n        JobStatus _status,\r\n        string memory _jobId,\r\n        string memory _jobTitle\r\n    ) {\r\n        return (\r\n            client,\r\n            freelancer,\r\n            amount,\r\n            platformFee,\r\n            freelancerAmount,\r\n            status,\r\n            jobId,\r\n            jobTitle\r\n        );\r\n    }\r\n    \r\n    function getBalance() external view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n}\r\n"
      },
      "project/contracts/JobFactory.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\nimport \"./JobEscrow.sol\";\r\n\r\ncontract JobFactory {\r\n    address public platform;\r\n    address public arbitrator;\r\n    uint256 public platformFeePercent;\r\n    \r\n    mapping(string => address) public jobContracts; // jobId => escrow contract address\r\n    address[] public allJobContracts;\r\n    \r\n    event JobCreated(\r\n        string indexed jobId,\r\n        address indexed escrowContract,\r\n        address indexed client,\r\n        string jobTitle\r\n    );\r\n    \r\n    modifier onlyPlatform() {\r\n        require(msg.sender == platform, \"Only platform can call this\");\r\n        _;\r\n    }\r\n    \r\n    constructor(address _arbitrator, uint256 _platformFeePercent) {\r\n        require(_arbitrator != address(0), \"Invalid arbitrator address\");\r\n        require(_platformFeePercent <= 100, \"Fee percent too high\");\r\n        \r\n        platform = msg.sender;\r\n        arbitrator = _arbitrator;\r\n        platformFeePercent = _platformFeePercent;\r\n    }\r\n    \r\n    // Create a new job escrow contract\r\n    function createJob(\r\n        string memory _jobId,\r\n        string memory _jobTitle\r\n    ) external returns (address) {\r\n        require(bytes(_jobId).length > 0, \"Job ID cannot be empty\");\r\n        require(jobContracts[_jobId] == address(0), \"Job already exists\");\r\n        \r\n        // Create new escrow contract\r\n        JobEscrow escrow = new JobEscrow(\r\n            msg.sender, // client\r\n            platform,\r\n            arbitrator,\r\n            platformFeePercent,\r\n            _jobId,\r\n            _jobTitle\r\n        );\r\n        \r\n        address escrowAddress = address(escrow);\r\n        jobContracts[_jobId] = escrowAddress;\r\n        allJobContracts.push(escrowAddress);\r\n        \r\n        emit JobCreated(_jobId, escrowAddress, msg.sender, _jobTitle);\r\n        \r\n        return escrowAddress;\r\n    }\r\n    \r\n    // Update platform fee (only platform owner)\r\n    function updatePlatformFee(uint256 _newFeePercent) external onlyPlatform {\r\n        require(_newFeePercent <= 100, \"Fee percent too high\");\r\n        platformFeePercent = _newFeePercent;\r\n    }\r\n    \r\n    // Update arbitrator (only platform owner)\r\n    function updateArbitrator(address _newArbitrator) external onlyPlatform {\r\n        require(_newArbitrator != address(0), \"Invalid arbitrator address\");\r\n        arbitrator = _newArbitrator;\r\n    }\r\n    \r\n    // Get escrow contract address by job ID\r\n    function getJobContract(string memory _jobId) external view returns (address) {\r\n        return jobContracts[_jobId];\r\n    }\r\n    \r\n    // Get total number of jobs created\r\n    function getTotalJobs() external view returns (uint256) {\r\n        return allJobContracts.length;\r\n    }\r\n    \r\n    // Get all job contracts (paginated)\r\n    function getJobContracts(uint256 _start, uint256 _limit) \r\n        external \r\n        view \r\n        returns (address[] memory) \r\n    {\r\n        require(_start < allJobContracts.length, \"Start index out of bounds\");\r\n        \r\n        uint256 end = _start + _limit;\r\n        if (end > allJobContracts.length) {\r\n            end = allJobContracts.length;\r\n        }\r\n        \r\n        uint256 size = end - _start;\r\n        address[] memory contracts = new address[](size);\r\n        \r\n        for (uint256 i = 0; i < size; i++) {\r\n            contracts[i] = allJobContracts[_start + i];\r\n        }\r\n        \r\n        return contracts;\r\n    }\r\n}\r\n"
      }
    }
  }
}